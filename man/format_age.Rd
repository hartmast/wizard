% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/format_age.R
\name{format_age}
\alias{format_age}
\title{Format age in child language data}
\usage{
format_age(x, col, month_separator = ";", day_separator = ".", factors = FALSE)
}
\arguments{
\item{x}{A vector or dataframe.}

\item{col}{If x is a dataframe: The column containing the
age values.}

\item{month_separator}{sign that separates months from years.
Defaults to ; as in 2;4.10}

\item{day_separator}{sign that separates days from months.
Defaults to . as in 2;4.10}

\item{factors}{If TRUE, the original formatting will be retained
but the factor levels will be rearranged to reflect the
correct temporal order (if x is a vector). If x is a dataframe,
the factor levels will be rearranged in the original column
but an age_formatted column will still be appended to the
original dataframe. To get rid of the column, use
x[,!names(x)=="age_formatted"]. Default is FALSE.}
}
\value{
a dataframe or a vector, depending on the input.
}
\description{
Convenience function for formatting age values:
In child language acquisition studies, age values ofte come in
formats like 2;1.10 (year;month.day), which causes problems when
sorting the data because they will typically be recognized as
character strings, and 2;10.5 will precede 2;1.10 because
of the 0 in the first character string. This function helps
to circumvent this problem by adding trailing zeros to all
one-digit month and day values. Its input can be either a vector
or a dataframe. Its output is a vector of formatted numbers
in the former case or a dataframe with an added column
age_formatted in the latter case. Alternatively, if you use
a dataframe as input, you can specify factors = TRUE, in which
case the original formatting will be kept but the factor levels
will be rearranged in such a way that the temporal order
is accurately reflected.
}
